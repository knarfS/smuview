SmuView
=======

ToDo

- Remove "hp3478a" from gpib_libgpib_name_ and list all available names.
- Use util::Timestamp?
- last_value_, min_value_, max_value_ -> std::atomic!
- License headers are not the same
- Plot: Sampling
- Mutex for aquisition_state_?
- QWT Multiaxis
- Autoscale plot
- Save session, save all data (gnuplot, octave, ...)

------------------------

Done

- Check in connect.cpp if GPIB is part of build info (libsigrok -> backend.c)
- Everey device must have its own session:
	1. Performance: With one sessions the aquisition functions are processed in sequence.
		The HP 3478A f.e. takes for ever, and so the other devices to. There are NO parallel
		requests.
	2. Adding new device to a running session: Chicken/Egg problem! Dev->open() tries to
		start aquisition, but device is not added to session yet (cxx binding).
		session->add_device() tries to start aquisition, but device is not opened yet...
	3. Solves the sr_session_source_add_internal() dublicate key problem.
	4. Propably use the multidevice API functions from linux gpib in scpi_libgpib.c

- Better detection of common_time_data_ (when in frame). Who is this possible when in
	init_signal() and not afterwards when in feed_in()
- QIcon (On/Off/Dis) -> Led: State(On/Off), Mode(En/Dis)
- ValueControl implement is_value_setable_/is_value_getable_ and disable/enable controls
- Save signals as CSV
- Math channels (for Power, resistance, Wh, Ah)
- Correlation between time bases (common, same count+fixed diff, "random")

------------------------

Search for:

pulse



libsigrok
=========

- Add GPIB address to libgpib:conn as paramenter
- Change key naming (see load + psu wiki pages)
- Provied SR_DF_META packets for the Re:load Pro and the HP3478A for changed values/states (e.g. output switched on/off, ovp, otp, ...)
- Re:load Pro: when acquisition is running and we send a command (e.g. "set xxx"), there are 2 listeners (1st send_cmd() (<-serial_write_blocking) and 2nd handle_new_data() (<-serial_read_nonblocking))
	- Make devc->acquisition_running thread safe, bool is NOT thread safe!
- Re:load Pro: when 2 responses are send fast afer each other, serial_read_nonblocking reads them both and the \r\n gets in beetween
- Re:load Pro: sometimes only a ^M is send from the rlp
- Re:load Pro: Sometimes the responses are mixed up (2 listeners??, Re:load Pro not keeping up??)
- Re:load Pro: how to clear otp_active and uvc_active?
- hp3478a: device isn't closed after stopping acquisition
- scpi-pps: protocol.c -> scpi_pps_receive_data() uses double, but output (e.g. analog) and DF_ANALOG receivers use hardcoded float. Using sr_analog_encoding.unitsize and .is_float to define the datatype (and size) (.unitsize = sizeof(double) (or by lurchi_: .unitsize=8 + float is double)) in the receiver functions!
- Tests for convertion (st_ascii_tod) for locale "bugs"
- use mutex around ibwrt() and ibrd() (scpi_libgpib.c) per device, so they are thread safe
- use mutex around scpi_cmd_resp() and scpi_cmd() (helpers.c), so when a request has a response, they are thread safe.
- dev_acquisition_start() has to do first measurement (3478a, scpi-pps, reload(?)), because 1. DF_HEADER, 2. trigger measurement
	- If not: 3378a use scpi_cmd_resp() for use of mutex (wrt+read);
- Can't add 2x scpi_libgpib devices: scpi_libgpib.c -> scpi_gpib_source_add() calls session.c -> sr_session_source_add() with fd = -1. This calls session.c -> sr_session_fd_source_add() with key = GINT_TO_POINTER(fd) and finally throws an error in session.c -> sr_session_source_add_internal() because "Event source with key %p already exists."
- scpi-pps's have channel groups but options/keys/_lists_ (voltage_target, ...) apply to device
- scpi-pps: when in acquisition send one write ":MEAS:VOLT?;:MEAS:CURR?" instead of 2 writes when possible
- scpi-pps: add otp/ovp/ocp to pps_profiles[] (or to channel(group)) for HP 663xx
- Mutex of scpi/helpers.c:
	- find all ocurrence of (sr_scpi_send_variadic(), sr_scpi_send(), scpi_cmd(), scpi_cmd_resp(), rigol_ds_config_set(), ....) and check if thread safe
	- Any functions missing, that need the mutex
	- Valid for SCPI over something something?
- Mutex of scpi_libgpib: Add to other transport variants (serial, tcp, ...), if so is the mutex in scpi/helpers.c enough?
- Add channel.meaning.mq, channel.meaning.mqflags, channel.meaning.unit (+channel.fixed) to PPU and load channels, to make it easy to init signals in smuview
- Re:load Pro: Don't use "monitor 200", Instead "read" values every aquisition cycle with serial "read line blocking" and use a mutex around every read, write and write+read
- HP3478A: Implement SPoll,

Done
----

- Re:load Pro: send "monitor 0" when device is scaned to stop eventually running monitoring and version can be read properly
- Re:load Pro: send "monitor 0" when device is closed
- Wrong string to float/double conversion (because of locale settings):
	- dmm/m2110.c: 2x sscanf((const char *)buf, "%f", &val) == 1 -> sr_atof_ascii((const char *)buf, &val) == SR_OK
	- motech-lps-30x/protocol.c: sr_atod(devc->buf, &dbl)
	- dmm/metex14.c: sscanf((const char *)&valstr, "%f", result) -> sr_atof_ascii((const char *)&valstr, result)
	- scpi/scpi.c: sr_atod(response, scpi_response) -> sr_atod_ascii(response, scpi_response)
- hp3478a: acquisition doesn't stop (sigrok-cli/smuview must be killed)



Doku
====

- Link API to the psu and load wiki pages



Re:load Pro Firmware
====================

- Add "output" command (returns "on" / "off") to determin in wich state the output is (git commit 448cf71, 558bc0e (part))
- Send "on" / "off" when output state was changed at the device directly
- Send "uvlo xxx" when undervoltage threshold was changed at the device directly (git commit 224ab62)
